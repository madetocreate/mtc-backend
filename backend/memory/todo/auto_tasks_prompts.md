

1. *Analysiere ein gegebenes Code-Snippet und erkläre, wie es funktioniert, welche Muster es verwendet und wie es optimiert werden kann.*
2. *Schreibe einen sauberen, gut dokumentierten Code für eine Funktion, die eine Liste sortiert, und erkläre die Zeitkomplexität.*
3. *Finde und behebe Bugs in einem Python-Skript, inklusive Exception-Handling und Unit Tests.*
4. *Refactore einen vorhandenen Codeblock, um die Lesbarkeit und Wartbarkeit zu verbessern.*
5. *Erstelle automatisierte Tests für eine gegebene Codebasis mit pytest oder unittest.*
6. *Schreibe einen Code, der eine REST API mit FastAPI oder Flask erstellt, inklusive Endpunktdokumentation.*
7. *Generiere Beispiel-Code, der eine Datenbankanbindung mit SQLAlchemy zeigt.*
8. *Simuliere eine Code-Review und gebe Verbesserungsvorschläge für einen Pull Request.*
9. *Erkläre den Unterschied zwischen synchronem und asynchronem Code, mit Beispiel in Python.*
10. *Implementiere ein einfaches Caching-System in Python zur Performance-Verbesserung.*
11. *Automatisiere eine Datenverarbeitungs-Pipeline inklusive Fehler-Logging.*
12. *Erstelle eine Funktion zum sicheren Umgang mit Benutzereingaben (Input Validation).*
13. *Simuliere das Schreiben eines Dokumentations-Blocks für ein größeres Python-Modul.*
14. *Schreibe einen Code, der eine einfache Textanalyse durchführt (z.B. Wortzählung).*
15. *Implementiere ein Retry-Mechanismus für fehlgeschlagene API-Anfragen mit Backoff-Strategie.*
16. *Erkläre die Prinzipien von Clean Code und wie man sie in einem Projekt anwendet.*
17. *Simuliere eine automatische Formatierung von Code mit tools wie Black oder Prettier.*
18. *Erstelle Beispielcode zur parallelen Ausführung von Tasks mit multiprocessing oder asyncio.*
19. *Baue ein Logging-Setup, das unterschiedliche Log-Level unterstützt und in Dateien schreibt.*
20. *Schreibe eine Funktion, die automatisierte Code-Dokumentationen generiert, z.B. mit Sphinx.*

---

### 30 Prompts zum **Netzwerk, Lernen & Selbstverbesserung**

21. *Analysiere vergangene Fehler und erstelle daraus eine Liste von Lessons Learned mit Verbesserungsvorschlägen.*
22. *Führe eine Linting-Analyse auf Codebasis durch und liste die häufigsten Fehler auf.*
23. *Erstelle eine Task-History mit Status, Fehlern, Lösungen und nächsten Schritten.*
24. *Simuliere eine Feedbackschleife, in der Nutzerkommentare genutzt werden, um den AI-Code zu verbessern.*
25. *Optimiere Speicher- und Performance-Management für lang laufende AI-Prozesse.*
26. *Entwickle einen Plan für automatisiertes Testen und Deployment (CI/CD).*
27. *Untersuche Code-Metriken und schlage Refactoring-Punkte vor.*
28. *Überprüfe die Einhaltung von Sicherheitsstandards im Code und identifiziere Risiken.*
29. *Erstelle eine Übersicht aller AI-Module mit ihren Funktionen und Abhängigkeiten.*
30. *Simuliere eine dynamische Priorisierung von Tasks basierend auf Wichtigkeit und Aufwand.*
31. *Implementiere eine Self-Healing-Strategie für fehlerhafte AI-Module.*
32. *Führe eine semantische Analyse des AI-Memory durch, um redundante Daten zu entfernen.*
33. *Erstelle automatische Benachrichtigungen für kritische Fehler oder Systemwarnungen.*
34. *Optimiere die AI-Eingabeverarbeitung, um Missverständnisse und Fehler zu minimieren.*
35. *Baue einen Prototyp für automatische Code-Reviews und Merge-Vorschläge.*
36. *Simuliere Lernprozesse, die aus früheren Fehlern Wissen generieren und speichern.*
37. *Erstelle ein Dashboard-Konzept zur Visualisierung von AI-Performance und Tasks.*
38. *Optimiere Datenbankabfragen und Speicherzugriffe auf Effizienz und Geschwindigkeit.*
39. *Führe einen Benchmark-Test durch, vergleiche Antwortzeiten und speichere Ergebnisse.*
40. *Simuliere eine Sicherheitsüberprüfung von Datenzugriffen und Speicheroperationen.*
41. *Erstelle einen Task-Router, der AI-Anfragen automatisch an spezialisierte Module verteilt.*
42. *Entwickle ein System zur automatischen Priorisierung von Bugs und Feature-Requests.*
43. *Erstelle eine Methodik für kontinuierliche Verbesserung basierend auf Task-Feedback.*
44. *Simuliere eine Versionskontrolle der AI-Prompts mit Rückwärtskompatibilität.*
45. *Optimiere AI-Ausgabequalität durch adaptive Prompt-Verfeinerung.*
46. *Entwickle eine automatische Dokumentationsgenerierung für AI-Module und Funktionen.*
47. *Simuliere ein Netzwerk aus Microservices und koordinieren deren Zusammenarbeit.*
48. *Erstelle ein Memory-Filter, der irrelevante oder alte Daten vor der Übergabe an AI aussortiert.*
49. *Implementiere ein System zur automatischen Analyse von Nutzerfeedback zur AI.*
50. *Entwickle eine Strategie zur automatischen Integration externer Updates und Bibliotheken.*


### 50 Ausführliche Prompts zum AI-Weiterentwickeln & Deep Dive in Code & Struktur

1. **Erkläre die Kernkonzepte von künstlicher Intelligenz, maschinellem Lernen und Deep Learning und wie sie sich technisch unterscheiden.**
2. **Analysiere den Aufbau einer typischen Webanwendung: Frontend, Backend, Datenbank – und beschreibe die Interaktion zwischen den Komponenten.**
3. **Untersuche die Vor- und Nachteile von monolithischer vs. mikroservicebasierter Architektur in modernen Websystemen.**
4. **Beschreibe den Lebenszyklus einer HTTP-Anfrage von Client bis Server und zurück inklusive Caching und Sicherheit.**
5. **Erkläre, wie REST-APIs funktionieren und welche Prinzipien bei der API-Design-Entwicklung beachtet werden sollten.**
6. **Tauche tief in das Thema State Management ein: Erkläre verschiedene Strategien (z.B. Redux, Context API, MobX) und deren Einsatzgebiete.**
7. **Analysiere und erkläre, wie Containerisierung (Docker) und Orchestrierung (Kubernetes) moderne Deployments vereinfachen.**
8. **Beschreibe die Rolle von Middleware in Webservern und wie man sie sinnvoll modular gestaltet.**
9. **Untersuche, wie OAuth 2.0 und JWT für sichere Authentifizierung und Autorisierung in Webanwendungen funktionieren.**
10. **Erkläre den Unterschied zwischen synchroner und asynchroner Programmierung und ihre Anwendungsfälle im Backend.**
11. **Führe eine detaillierte Analyse von Design Patterns in der Softwareentwicklung durch und gib Beispiele für deren Anwendung in Python oder JS.**
12. **Beschreibe, wie Continuous Integration und Continuous Deployment (CI/CD) Pipelines aufgebaut werden und welche Tools dafür eingesetzt werden.**
13. **Untersuche die Prinzipien von Clean Architecture und wie man sie auf modulare AI- und Websysteme anwendet.**
14. **Erkläre, wie Event-Driven Architecture funktioniert und welche Vorteile sie in skalierbaren Systemen bringt.**
15. **Beschreibe, wie man automatisierte Tests für Backend und Frontend entwickelt und integriert.**
16. **Tauche ein in das Thema API-Gateway: Rolle, Vorteile und wie es in Microservice-Architekturen eingesetzt wird.**
17. **Erkläre, wie Datenbanken normalisiert werden und wann Denormalisierung sinnvoll ist – inklusive Beispielanwendungen.**
18. **Beschreibe den Prozess des Daten-Caching auf mehreren Ebenen (Client, Server, CDN) zur Performance-Optimierung.**
19. **Analysiere die Sicherheitsaspekte moderner Webanwendungen: XSS, CSRF, SQL Injection und entsprechende Gegenmaßnahmen.**
20. **Erkläre, wie WebSockets funktionieren und wie man sie für Echtzeit-Kommunikation implementiert.**
21. **Beschreibe die Funktionsweise und Bedeutung von Load Balancern im Web-Traffic-Management.**
22. **Tauche in GraphQL ein: Wie funktioniert es, welche Vorteile bietet es gegenüber REST und wie baut man eine GraphQL-API.**
23. **Erkläre das Konzept von Container-Images und -Registries, inklusive Best Practices für Versionierung und Sicherheit.**
24. **Analysiere, wie AI-Modelle trainiert, evaluiert und in Produktionssysteme integriert werden.**
25. **Beschreibe die Bedeutung und den Aufbau von Feature Flags für die schrittweise Einführung von Funktionen.**
26. **Erkläre, wie Serverless-Computing funktioniert und welche Use Cases dafür besonders geeignet sind.**
27. **Untersuche, wie man AI-getriebene Chatbots mit Natural Language Processing und Dialogmanagement umsetzt.**
28. **Erkläre, wie das Publish-Subscribe-Muster funktioniert und wie es in verteilten Systemen eingesetzt wird.**
29. **Beschreibe, wie man eine modulare Codebasis aufbaut, die leicht erweiterbar und testbar ist.**
30. **Analysiere den Unterschied zwischen statischer und dynamischer Typisierung, Vor- und Nachteile.**
31. **Erkläre, wie AI-Systeme mit externen APIs kommunizieren und wie man stabile Schnittstellen gestaltet.**
32. **Beschreibe Strategien für das Monitoring und Logging von verteilten AI- und Websystemen.**
33. **Tauche in die Grundlagen von Container-Netzwerken ein und wie Services in einem Cluster kommunizieren.**
34. **Erkläre die Prinzipien von Domain-Driven Design und wie sie in komplexen Softwareprojekten Anwendung finden.**
35. **Beschreibe, wie man skalierbare Datenpipelines für AI-Trainingsdaten entwirft und implementiert.**
36. **Untersuche, wie Cloud-Provider Services (z.B. AWS Lambda, Azure Functions) AI-Workloads unterstützen.**
37. **Erkläre, wie man State-of-the-Art KI-Modelle wie GPT oder BERT in eigene Projekte einbindet.**
38. **Beschreibe, wie man AI-Modelle mit Transfer Learning an spezifische Anwendungsfälle anpasst.**
39. **Analysiere, wie man robuste Fehlerbehandlung und Recovery-Strategien in AI-Pipelines realisiert.**
40. **Erkläre, wie man komplexe Web-UIs mit React, Vue oder Angular strukturiert und performant hält.**
41. **Beschreibe, wie man RESTful API-Versionierung sinnvoll umsetzt, um Breaking Changes zu vermeiden.**
42. **Erkläre den Aufbau und Nutzen von Message Queues wie RabbitMQ oder Kafka in skalierbaren Architekturen.**
43. **Untersuche, wie man AI-gestützte Recommendation Engines für Nutzerpersonalisierung baut.**
44. **Beschreibe die Prinzipien und Praxis von Container-Sicherheit und Secrets Management.**
45. **Erkläre, wie man automatisierte Datenvalidierung und -bereinigung in AI-Projekten implementiert.**
46. **Beschreibe Strategien zur Optimierung von Latenz und Durchsatz in verteilten Systemen.**
47. **Analysiere, wie man komplexe Geschäftslogiken in Microservices sauber kapselt und orchestriert.**
48. **Erkläre den Umgang mit API Rate Limits und Strategien zum Throttling.**
49. **Beschreibe die Grundlagen von Event Sourcing und wie man es für AI-gestützte Audit-Trails nutzt.**
50. **Erkläre, wie man Cloud-natives Monitoring und Tracing (z.B. OpenTelemetry) für AI-Systeme aufbaut.**


